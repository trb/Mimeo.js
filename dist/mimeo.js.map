{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","browser.js","mimeo.js","src/Mimeo.js","src/Module.js","src/dependencies/DependencyManager.js","src/dependencies/DependencyResolver.js","src/dependencies/Graph.js","src/dependencies/Injectables.js","src/dependencies/Modules.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","mimeo","./src/Mimeo.js",2,"Module","modules","injectables","Mimeo","instantiateInjectables","hasAllDependencies","getMissingDependencies","instantiate","bootstrapToString","bootstrap","element","injectableName","get","name","dependencies","add","./Module.js","./dependencies/Injectables.js","./dependencies/Modules.js",3,"addInjectable","parameters","has","injectable","Function","$inject","slice","$name","this","service","factory","directive","value",4,"DependencyManager","register","entity","_getMissingDependenciesCache","undefined","_providers","_dependencies","forEach","dependency","addDependency","providersInjects","Object","keys","map","providerName","concat","apply","filter","Boolean","getResolutionOrder","provider","_instances","dependencyName","getProvider","getInstance","DependencyResolver","./DependencyResolver.js",5,"Graph","graph","hasNodeValue","addEdge","getNodesTopological","node","./Graph.js",6,"Node","_id","Math","random","toString","Edge","nodeFrom","nodeTo","_from","_to","makeNodeIdentifier","node1","node2","prototype","getNodeIdentifier","_nodes","_nodesById","_nodesByValue","_zeroIngreeNodes","_edges","_edgesByNodes","_edgesByTo","_edgesByFrom","reset","addNode","push","edge","existingNode","removeEdge","edgeToRemove","getNodeByValue","fromValue","toValue","fromNode","toNode","sortedNodes","currentNode","pop",7,"./DependencyManager.js",8,"instantiateModules"],"mappings":"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","file":"mimeo.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","mimeo = require('./src/Mimeo.js');",null,"var Module = require('./Module.js');\n\nvar modules = require('./dependencies/Modules.js');\nvar injectables = require('./dependencies/Injectables.js');\n\nvar Mimeo = function() {\n    function instantiateInjectables() {\n        if (!injectables.hasAllDependencies()) {\n            throw 'Injectables don\\'t exist: ' + injectables.getMissingDependencies();\n        }\n\n        injectables.instantiate();\n    }\n\n    function bootstrapToString() {\n        modules.instantiate();\n        instantiateInjectables();\n    }\n\n    function bootstrap(element, injectableName) {\n        modules.instantiate();\n        instantiateInjectables();\n\n        injectables.get(injectableName)(element);\n    }\n\n    return {\n        module: function(name, dependencies) {\n            if (dependencies) {\n                return modules.add(new Module(name, dependencies));\n            }\n\n            return modules.get(name);\n        },\n        bootstrapToString: bootstrapToString,\n        bootstrap: bootstrap\n    }\n};\n\nmodule.exports = Mimeo();","var injectables = require('./dependencies/Injectables.js');\n\nfunction Module(name, dependencies) {\n    var module = this;\n\n    this.$name = name;\n    this.$inject = dependencies;\n\n    function addInjectable(name, parameters) {\n        if (injectables.has(name)) {\n            throw 'Injectable \"' + name + '\" already exists';\n        }\n\n        var injectable;\n\n        if (parameters instanceof Function) {\n            injectable = parameters;\n            if (!injectable.$inject) {\n                injectable.$inject = [];\n            }\n        } else {\n            var dependencies = parameters.slice(0, -1);\n            injectable = parameters.slice(-1)[0];\n            injectable.$inject = dependencies;\n        }\n\n        injectable.$name = name;\n\n        injectables.add(injectable);\n\n        return module;\n    }\n\n    this.service = addInjectable;\n    this.factory = addInjectable;\n    this.directive = addInjectable;\n    this.value = function(name, value) {\n        return addInjectable(name, function() {\n            return value;\n        });\n    }\n}\n\nmodule.exports = Module;","var DependencyResolver = require('./DependencyResolver.js');\n\n/**\n *\n * @param name\n * @returns {{$name: string, register: register, hasAllDependencies:\n *     hasAllDependencies, instantiate: instantiate, getInstance: getInstance}}\n * @constructor\n */\nfunction DependencyManager(name) {\n    var _providers = {};\n    var _instances = {};\n    var _dependencies = DependencyResolver();\n\n    var _getMissingDependenciesCache = undefined;\n\n    function register(entity) {\n        if (!entity.$name || !entity.$inject) {\n            throw 'Entity \"' + entity.$name + '\" is missing $name or $inject';\n        }\n\n        _getMissingDependenciesCache = undefined;\n\n        _providers[entity.$name] = entity;\n        _dependencies.register(entity.$name);\n        entity.$inject.forEach(function(dependency) {\n            _dependencies.addDependency(entity.$name, dependency);\n        });\n    }\n\n    function getMissingDependencies() {\n        if (_getMissingDependenciesCache) {\n            return _getMissingDependenciesCache;\n        }\n\n        var providersInjects = Object.keys(_providers).map(function(providerName) {\n            return _providers[providerName].$inject;\n        });\n\n        _getMissingDependenciesCache = [].concat.apply(providersInjects).filter(function(providerName) {\n            return !Boolean(_providers[providerName]);\n        });\n\n        return _getMissingDependenciesCache;\n    }\n\n    function hasAllDependencies() {\n        return getMissingDependencies().length > 0;\n    }\n\n    function instantiate() {\n        _dependencies.getResolutionOrder().forEach(function(providerName) {\n            var provider = _providers[providerName];\n\n            _instances[providerName] = provider.apply(provider, provider.$inject.map(function(dependencyName) {\n                return _instances[dependencyName];\n            }));\n        });\n    }\n\n    function getProvider(providerName) {\n        return _providers[providerName];\n    }\n\n    function getInstance(providerName) {\n        return _instances[providerName];\n    }\n\n    return {\n        $name: name,\n        register: register,\n        hasAllDependencies: hasAllDependencies,\n        getMissingDependencies: getMissingDependencies,\n        instantiate: instantiate,\n        getProvider: getProvider,\n        getInstance: getInstance\n    }\n}\n\n/**\n *\n * @param name\n * @returns {DependencyManager}\n */\nmodule.exports = function(name) {\n    return new DependencyManager(name);\n};","var Graph = require('./Graph.js');\n\n/**\n * Allows to register module, dependencies and get the order in which\n * modules need to be instantiated to fulfill all dependencies. It purely\n * resolves dependencies, module instances need to be handled separately.\n *\n * @returns {{register: register, addDependency: addDependency,\n *     getResolutionOrder: getResolutionOrder}}\n * @constructor\n */\nvar DependencyResolver = function() {\n    var graph = new Graph();\n\n    function register(module) {\n        if (!graph.hasNodeValue(module)) {\n            graph.add(module);\n        }\n    }\n\n    function addDependency(module, dependency) {\n        // Optimistically add a module if the dependency module doesn't\n        // exist yet. It's possible to create dependencies on non-existing\n        // modules, the user of the class has to handle that case.\n        if (!graph.hasNodeValue(dependency)) {\n            register(dependency);\n        }\n\n        graph.addEdge(dependency, module);\n    }\n\n    function getResolutionOrder() {\n        return graph.getNodesTopological().map(function(node) {\n            return node.value;\n        });\n    }\n\n    return {\n        register: register,\n        addDependency: addDependency,\n        getResolutionOrder: getResolutionOrder\n    };\n};\n\n/**\n *\n * @returns {DependencyResolver}\n */\nmodule.exports = function() {\n    return new DependencyResolver();\n};","var Node = function(value) {\n    this._id = Math.random().toString(36);\n    this.value = value;\n};\n\n\nvar Edge = function(nodeFrom, nodeTo) {\n    this._id = Math.random().toString(36);\n    this._from = nodeFrom;\n    this._to = nodeTo;\n};\n\nvar makeNodeIdentifier = function(node1, node2) {\n    return node1._id + ':' + node2._id;\n};\n\nEdge.prototype.getNodeIdentifier = function() {\n    return makeNodeIdentifier(this._from, this._to);\n};\n\n/**\n * Directed graph to order nodes by dependencies. Favors precomputating lookup\n * tables over lookups at sort time. Most machines have lots of ram and\n * especially on mobile the CPU is more restricted. Using more ram and less\n * CPU cycles is preferable in those conditions, although it should hardly\n * matter since most dependency graphs (which this implementation is focused\n * on) shouldn't exceed a few hundred nodes.\n *\n * @returns {{add: Function, addEdge: Function, hasNodeValue: Function,\n *     getNodesTopological: Function}}\n * @constructor\n */\nvar Graph = function() {\n    var _nodes = [];\n    var _nodesById = {};\n    var _nodesByValue = {};\n    var _zeroIngreeNodes = [];\n    var _edges = [];\n    var _edgesByNodes = {};\n    var _edgesByTo = {};\n    var _edgesByFrom = {};\n\n    /*\n     * The current topological sort implementation mutates the graph, after\n     * which it's unusable. This function allows to clean the entire graph\n     * up, removing any dangling data that might be left after the sort.\n     */\n    var reset = function() {\n        _nodes = [];\n        _nodesById = {};\n        _nodesByValue = {};\n        _zeroIngreeNodes = [];\n        _edges = [];\n        _edgesByNodes = {};\n        _edgesByTo = {};\n        _edgesByFrom = {};\n    };\n\n    var addNode = function(node) {\n        if (_nodesByValue[node.value]) {\n            throw 'Duplicate values not allowed. Node with value \"' + node.value + '\" already exists';\n        }\n\n        _nodes.push(node);\n        _nodesById[node._id] = node;\n        _nodesByValue[node.value] = node;\n\n        _zeroIngreeNodes.push(node);\n    };\n\n    var addEdge = function(edge) {\n        if (_edgesByNodes[edge.getNodeIdentifier()]) {\n            return;\n        }\n\n        _edges.push(edge);\n        _edgesByNodes[edge.getNodeIdentifier()] = edge;\n\n        if (!_edgesByFrom[edge._from._id]) {\n            _edgesByFrom[edge._from._id] = [];\n        }\n        _edgesByFrom[edge._from._id].push(edge);\n\n        if (!_edgesByTo[edge._to._id]) {\n            _edgesByTo[edge._to._id] = [];\n        }\n        _edgesByTo[edge._to._id].push(edge);\n\n        _zeroIngreeNodes = _zeroIngreeNodes.filter(function(existingNode) {\n            return existingNode._id != edge._to._id;\n        });\n    };\n    var removeEdge = function(edgeToRemove) {\n        _edges = _edges.filter(function(edge) {\n            return edge._id != edgeToRemove._id;\n        });\n\n        delete _edgesByNodes[edgeToRemove.getNodeIdentifier()];\n        if (_edgesByFrom[edgeToRemove._from._id]) {\n            _edgesByFrom[edgeToRemove._from._id] = _edgesByFrom[edgeToRemove._from._id].filter(function(edge) {\n                return edge._id != edgeToRemove._id;\n            });\n        }\n        if (_edgesByTo[edgeToRemove._to._id]) {\n            _edgesByTo[edgeToRemove._to._id] = _edgesByTo[edgeToRemove._to._id].filter(function(edge) {\n                return edge._id != edgeToRemove._id;\n            });\n        }\n    };\n\n    var getNodeByValue = function(value) {\n        return _nodesByValue[value];\n    };\n\n    return {\n        add: function(value) {\n            addNode(new Node(value));\n        },\n        addEdge: function(fromValue, toValue) {\n            var fromNode = getNodeByValue(fromValue);\n            var toNode = getNodeByValue(toValue);\n\n            if (!fromNode && !toNode) {\n                throw 'Neither from- nor to-node exist: ' + fromValue + ', ' + toValue;\n            }\n\n            if (!fromNode) {\n                throw 'From-node doesn\\'t exist: ' + fromValue;\n            }\n\n            if (!toNode) {\n                throw 'To-node doesn\\'t exist: ' + toValue;\n            }\n\n            addEdge(new Edge(fromNode, toNode));\n        },\n        hasNodeValue: function(value) {\n            return Boolean(getNodeByValue(value));\n        },\n        getNodesTopological: function() {\n            var sortedNodes = [];\n\n            while (_zeroIngreeNodes.length > 0) {\n                var currentNode = _zeroIngreeNodes.pop();\n                sortedNodes.push(currentNode);\n                (_edgesByFrom[currentNode._id] || []).slice(0).forEach(function(edge) {\n                    removeEdge(edge);\n                    if (!_edgesByTo[edge._to._id] || _edgesByTo[edge._to._id].length < 1) {\n                        _zeroIngreeNodes.push(edge._to);\n                    }\n                });\n            }\n\n            if (_edges.length > 0) {\n                reset();\n\n                throw 'Cycle detected, remaining edges: ' + _edges.map(function(edge) {\n                    return '(' + edge._from.value + ',' + edge._to.value + ')';\n                });\n            }\n\n            reset();\n\n            return sortedNodes;\n        }\n    };\n};\n\nmodule.exports = Graph;","var injectables = require('./DependencyManager.js')('injectables');\n\nfunction add(injectable) {\n    injectables.register(injectable);\n    return injectable;\n}\n\nfunction instantiateInjectables() {\n    if (!injectables.hasAllDependencies()) {\n        throw 'Injectables don\\'t exist: ' + injectables.getMissingDependencies();\n    }\n\n    injectables.instantiate();\n}\n\nfunction has(name) {\n    return Boolean(injectables.getProvider(name));\n}\n\nfunction get(name) {\n    return injectables.getInstance(name);\n}\n\nfunction hasAllDependencies() {\n    return injectables.hasAllDependencies();\n}\n\nmodule.exports = {\n    add: add,\n    get: get,\n    has: has,\n    instantiate: instantiateInjectables,\n    hasAllDependencies: hasAllDependencies\n};","var modules = require('./DependencyManager.js')('modules');\n\nfunction add(module) {\n    modules.register(module);\n    return module;\n}\n\nfunction instantiateModules() {\n    if (!modules.hasAllDependencies()) {\n        throw 'Modules don\\'t exist: ' + modules.getMissingDependencies();\n    }\n}\n\nfunction get(name) {\n    return modules.getProvider(name);\n}\n\nmodule.exports = {\n    add: add,\n    get: get,\n    instantiate: instantiateModules\n};"],"sourceRoot":"/source/"}