{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","browser.js","mimeo.js","src/Mimeo.js","src/Module.js","src/dependencies/DependencyManager.js","src/dependencies/Graph.js","src/dependencies/Injectables.js","src/dependencies/Modules.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","mimeo","./src/Mimeo.js",2,"Module","Modules","Injectables","Mimeo","instantiateInjectables","injectables","hasAllDependencies","getMissingDependencies","instantiate","bootstrap","injectableName","modules","entryInjectable","get","apply","Array","prototype","slice","arguments","name","dependencies","add","./Module.js","./dependencies/Injectables.js","./dependencies/Modules.js",3,"addInjectable","parameters","has","injectable","Function","$inject","$name","this","factory","component","value",4,"DependencyManager","register","entity","_providers","_getMissingDependenciesCache","undefined","_graph","hasNodeValue","forEach","dependency","addEdge","providersInjects","Object","keys","map","providerName","concat","filter","Boolean","getNodesTopological","provider","_instances","dependencyName","getProvider","getInstance","Graph","./Graph.js",5,"Node","String","_id","Math","random","toString","Edge","nodeFrom","nodeTo","_from","_to","makeNodeIdentifier","node1","node2","getNodeIdentifier","_nodes","_nodesById","_nodesByValue","_zeroIngreeNodes","_edges","_edgesByNodes","_edgesByTo","_edgesByFrom","reset","addNode","node","push","edge","existingNode","removeEdge","edgeToRemove","getNodeByValue","fromValue","toValue","fromNode","toNode","sortedNodes","currentNode","pop","remainingEdges",6,"./DependencyManager.js",7,"instantiateModules"],"mappings":"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","file":"mimeo.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","mimeo = require('./src/Mimeo.js');",null,"var Module = require('./Module.js');\n\nvar Modules = require('./dependencies/Modules.js');\nvar Injectables = require('./dependencies/Injectables.js');\n\nvar Mimeo = function() {\n    var modules = Modules();\n    var injectables = Injectables();\n\n    function instantiateInjectables() {\n        if (!injectables.hasAllDependencies()) {\n            throw new Error('Injectables don\\'t exist: ' + injectables.getMissingDependencies());\n        }\n\n        injectables.instantiate();\n    }\n\n    function bootstrap(injectableName) {\n        if (!injectableName) {\n            throw new Error('Define an injectable to bootstrap!');\n        }\n\n        modules.instantiate();\n\n        instantiateInjectables();\n\n        var entryInjectable = injectables.get(injectableName);\n\n        return entryInjectable.apply(entryInjectable, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return {\n        module: function(name, dependencies) {\n            if (dependencies) {\n                return modules.add(new Module(injectables, name, dependencies));\n            }\n\n            return modules.get(name);\n        },\n        bootstrap: bootstrap\n    }\n};\n\nmodule.exports = Mimeo();\n","function Module(injectables, name, dependencies) {\n    var module = this;\n\n    this.$name = name;\n    this.$inject = dependencies;\n\n    function addInjectable(name, parameters) {\n        if (injectables.has(name)) {\n            throw new Error('Injectable \"' + name + '\" already exists');\n        }\n\n        var injectable;\n\n        if (parameters instanceof Function) {\n            injectable = parameters;\n            if (!injectable.$inject) {\n                injectable.$inject = [];\n            }\n        } else {\n            var dependencies = parameters.slice(0, -1);\n            injectable = parameters.slice(-1)[0];\n            injectable.$inject = dependencies;\n        }\n\n        injectable.$name = name;\n\n        injectables.add(injectable);\n\n        return module;\n    }\n\n    this.factory = addInjectable;\n    this.component = addInjectable;\n    this.value = function(name, value) {\n        return addInjectable(name, function() {\n            return value;\n        });\n    }\n}\n\nmodule.exports = Module;","//var DependencyResolver = require('./DependencyResolver.js');\nvar Graph = require('./Graph.js');\n\n/**\n *\n * @param name\n * @returns {{$name: string, register: register, hasAllDependencies:\n *     hasAllDependencies, instantiate: instantiate, getInstance: getInstance}}\n * @constructor\n */\nfunction DependencyManager(name) {\n    var _providers = {};\n    var _instances = {};\n    var _graph = new Graph();\n\n    var _getMissingDependenciesCache = undefined;\n\n    function register(entity) {\n        if (!entity) {\n            throw new Error('No entity to register was given');\n        }\n\n        if (!entity.$name) {\n            throw new Error('Entity \"' + entity.$name + '\" is missing property $name');\n        }\n\n        if (!entity.$inject) {\n            throw new Error('Entity \"' + entity.$name + '\" is missing property $inject');\n        }\n\n        if (_providers[entity.$name]) {\n            throw new Error('Entity \"' + entity.$name + '\" already exists');\n        }\n\n        _getMissingDependenciesCache = undefined;\n\n        _providers[entity.$name] = entity;\n\n        /*\n         * Name might've been registered as a dependency of another entity\n         */\n        if (!_graph.hasNodeValue(entity.$name)) {\n            _graph.add(entity.$name);\n        }\n\n        entity.$inject.forEach(function(dependency) {\n            if (!_graph.hasNodeValue(dependency)) {\n                _graph.add(dependency);\n            }\n\n            _graph.addEdge(dependency, entity.$name);\n        });\n    }\n\n    function getMissingDependencies() {\n        if (_getMissingDependenciesCache) {\n            return _getMissingDependenciesCache;\n        }\n\n        var providersInjects = Object.keys(_providers).map(function(providerName) {\n            return _providers[providerName].$inject;\n        });\n\n        _getMissingDependenciesCache = [].concat.apply([], providersInjects).filter(function(providerName) {\n            return !Boolean(_providers[providerName]);\n        });\n\n        return _getMissingDependenciesCache;\n    }\n\n    function hasAllDependencies() {\n        return getMissingDependencies().length == 0;\n    }\n\n    function instantiate() {\n        _graph.getNodesTopological().forEach(function(providerName) {\n            var provider = _providers[providerName];\n\n            _instances[providerName] = provider.apply(provider, provider.$inject.map(function(dependencyName) {\n                return _instances[dependencyName];\n            }));\n        });\n    }\n\n    function getProvider(providerName) {\n        return _providers[providerName];\n    }\n\n    function getInstance(providerName) {\n        return _instances[providerName];\n    }\n\n    return {\n        $name: name,\n        register: register,\n        hasAllDependencies: hasAllDependencies,\n        getMissingDependencies: getMissingDependencies,\n        instantiate: instantiate,\n        getProvider: getProvider,\n        getInstance: getInstance\n    }\n}\n\n/**\n *\n * @param name\n * @returns {DependencyManager}\n */\nmodule.exports = function(name) {\n    return new DependencyManager(name);\n};","var Node = function(value) {\n    if (!(value instanceof String || typeof value === 'string')) {\n        throw new Error('Only strings are accepted as node values');\n    }\n\n    this._id = Math.random().toString(36);\n    this.value = value;\n};\n\n\nvar Edge = function(nodeFrom, nodeTo) {\n    this._id = Math.random().toString(36);\n    this._from = nodeFrom;\n    this._to = nodeTo;\n};\n\nvar makeNodeIdentifier = function(node1, node2) {\n    return node1._id + ':' + node2._id;\n};\n\nEdge.prototype.getNodeIdentifier = function() {\n    return makeNodeIdentifier(this._from, this._to);\n};\n\n/**\n * Directed graph to order nodes by dependencies. Only handles values whose\n * .toString() function returns unique values. Favors pre-computed lookup\n * tables over lookups at sort time. Most machines have lots of ram and\n * especially on mobile the CPU is more restricted. Using more ram and less\n * CPU cycles is preferable in those conditions, although it should hardly\n * matter since most dependency graphs (which this implementation is focused\n * on) shouldn't exceed a few hundred nodes.\n *\n * @returns {{add: Function, addEdge: Function, hasNodeValue: Function,\n *     getNodesTopological: Function}}\n * @constructor\n */\nvar Graph = function() {\n    var _nodes = [];\n    var _nodesById = {};\n    var _nodesByValue = {};\n    var _zeroIngreeNodes = [];\n    var _edges = [];\n    var _edgesByNodes = {};\n    var _edgesByTo = {};\n    var _edgesByFrom = {};\n\n    /*\n     * The current topological sort implementation mutates the graph, after\n     * which it's unusable. This function allows to clean the entire graph\n     * up, removing any dangling data that might be left after the sort.\n     */\n    var reset = function() {\n        _nodes = [];\n        _nodesById = {};\n        _nodesByValue = {};\n        _zeroIngreeNodes = [];\n        _edges = [];\n        _edgesByNodes = {};\n        _edgesByTo = {};\n        _edgesByFrom = {};\n    };\n\n    var addNode = function(node) {\n        if (_nodesByValue[node.value]) {\n            throw new Error('Duplicate values not allowed. Node with value \"' + node.value + '\" already exists');\n        }\n\n        _nodes.push(node);\n        _nodesById[node._id] = node;\n        _nodesByValue[node.value] = node;\n\n        _zeroIngreeNodes.push(node);\n    };\n\n    var addEdge = function(edge) {\n        if (_edgesByNodes[edge.getNodeIdentifier()]) {\n            return;\n        }\n\n        _edges.push(edge);\n        _edgesByNodes[edge.getNodeIdentifier()] = edge;\n\n        if (!_edgesByFrom[edge._from._id]) {\n            _edgesByFrom[edge._from._id] = [];\n        }\n        _edgesByFrom[edge._from._id].push(edge);\n\n        if (!_edgesByTo[edge._to._id]) {\n            _edgesByTo[edge._to._id] = [];\n        }\n        _edgesByTo[edge._to._id].push(edge);\n\n        _zeroIngreeNodes = _zeroIngreeNodes.filter(function(existingNode) {\n            return existingNode._id != edge._to._id;\n        });\n    };\n    var removeEdge = function(edgeToRemove) {\n        _edges = _edges.filter(function(edge) {\n            return edge._id != edgeToRemove._id;\n        });\n\n        delete _edgesByNodes[edgeToRemove.getNodeIdentifier()];\n\n        _edgesByFrom[edgeToRemove._from._id] = _edgesByFrom[edgeToRemove._from._id].filter(function(edge) {\n            return edge._id != edgeToRemove._id;\n        });\n\n        _edgesByTo[edgeToRemove._to._id] = _edgesByTo[edgeToRemove._to._id].filter(function(edge) {\n            return edge._id != edgeToRemove._id;\n        });\n    };\n\n    var getNodeByValue = function(value) {\n        return _nodesByValue[value];\n    };\n\n    return {\n        add: function(value) {\n            addNode(new Node(value));\n        },\n        addEdge: function(fromValue, toValue) {\n            var fromNode = getNodeByValue(fromValue);\n            var toNode = getNodeByValue(toValue);\n\n            if (!fromNode && !toNode) {\n                throw 'Neither from- nor to-node exist: ' + fromValue + ', ' + toValue;\n            }\n\n            if (!fromNode) {\n                throw 'From-node doesn\\'t exist: ' + fromValue;\n            }\n\n            if (!toNode) {\n                throw 'To-node doesn\\'t exist: ' + toValue;\n            }\n\n            addEdge(new Edge(fromNode, toNode));\n        },\n        hasNodeValue: function(value) {\n            return Boolean(getNodeByValue(value));\n        },\n        getNodesTopological: function() {\n            var sortedNodes = [];\n\n            while (_zeroIngreeNodes.length > 0) {\n                var currentNode = _zeroIngreeNodes.pop();\n                sortedNodes.push(currentNode);\n                (_edgesByFrom[currentNode._id] || []).slice(0).forEach(function(edge) {\n                    removeEdge(edge);\n                    if (!_edgesByTo[edge._to._id] || _edgesByTo[edge._to._id].length < 1) {\n                        _zeroIngreeNodes.push(edge._to);\n                    }\n                });\n            }\n\n            if (_edges.length > 0) {\n                var remainingEdges = _edges.map(function(edge) {\n                    return '(' + edge._from.value + ',' + edge._to.value + ')';\n                });\n\n                reset();\n\n                throw new Error('Cycle detected, remaining edges: ' + remainingEdges);\n            }\n\n            reset();\n\n            return sortedNodes.map(function(node) {\n                return node.value;\n            });\n        }\n    };\n};\n\nmodule.exports = Graph;","var DependencyManager = require('./DependencyManager.js');\n\nmodule.exports = function() {\n    var injectables = DependencyManager('injectables');\n\n    function add(injectable) {\n        injectables.register(injectable);\n        return injectable;\n    }\n\n    function instantiateInjectables() {\n        if (!injectables.hasAllDependencies()) {\n            throw new Error('Injectables don\\'t exist: ' + injectables.getMissingDependencies());\n        }\n\n        injectables.instantiate();\n    }\n\n    function has(name) {\n        return Boolean(injectables.getProvider(name));\n    }\n\n    function get(name) {\n        return injectables.getInstance(name);\n    }\n\n    function hasAllDependencies() {\n        return injectables.hasAllDependencies();\n    }\n\n    function getMissingDependencies() {\n        return injectables.getMissingDependencies();\n    }\n\n    return {\n        add: add,\n        get: get,\n        has: has,\n        instantiate: instantiateInjectables,\n        hasAllDependencies: hasAllDependencies,\n        getMissingDependencies: getMissingDependencies\n    };\n};","var DependencyManager = require('./DependencyManager.js');\n\nmodule.exports = function() {\n    var modules = DependencyManager('modules');\n\n    function add(module) {\n        modules.register(module);\n        return module;\n    }\n\n    function instantiateModules() {\n        if (!modules.hasAllDependencies()) {\n            throw new Error('Modules don\\'t exist: ' + modules.getMissingDependencies());\n        }\n    }\n\n    function get(name) {\n        return modules.getProvider(name);\n    }\n\n    return {\n        add: add,\n        get: get,\n        instantiate: instantiateModules\n    };\n};"],"sourceRoot":"/source/"}