{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","browser.js","mimeo.js","node_modules/parseuri/index.js","node_modules/route-recognizer/dist/route-recognizer.js","src/Mimeo.js","src/Module.js","src/builtins/Promise.js","src/builtins/Register.js","src/builtins/Routing.js","src/dependencies/DependencyManager.js","src/dependencies/Graph.js","src/dependencies/Injectables.js","src/dependencies/Modules.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","mimeo","./src/Mimeo.js",2,"re","parts","str","src","b","indexOf","substring","replace","m","exec","uri","source","host","authority","ipv6uri",3,"$$route$recognizer$dsl$$Target","path","matcher","delegate","this","$$route$recognizer$dsl$$Matcher","target","routes","children","$$route$recognizer$dsl$$generateMatch","startingPath","nestedCallback","fullPath","$$route$recognizer$dsl$$addRoute","routeArray","handler","len","substr","route","push","$$route$recognizer$dsl$$eachRoute","baseRoute","callback","binding","hasOwnProperty","slice","$$route$recognizer$$isArray","test","Object","prototype","toString","$$route$recognizer$$StaticSegment","string","$$route$recognizer$$DynamicSegment","name","$$route$recognizer$$StarSegment","$$route$recognizer$$EpsilonSegment","$$route$recognizer$$parse","names","specificity","charAt","segments","split","results","val","match","segment","$$route$recognizer$$State","charSpec","nextStates","$$route$recognizer$$sortSolutions","states","sort","$$route$recognizer$$recognizeChar","ch","state","concat","$$route$recognizer$$RecognizeResults","queryParams","$$route$recognizer$$findHandler","handlers","regex","captures","currentCapture","result","params","j","isDynamic","$$route$recognizer$$addSegment","currentState","eachChar","put","$$route$recognizer$$decodeQueryParamPart","part","decodeURIComponent","to","willAddRoute","add","addChild","contextEntered","$$route$recognizer$dsl$$default","addRouteCallback","$$route$recognizer$$specials","$$route$recognizer$$escapeRegex","RegExp","join","validChars","generate","invalidChars","repeat","get","child","isEqual","chars","returned","$$route$recognizer$$oCreate","create","proto","F","splice","Array","$$route$recognizer$$RouteRecognizer","rootState","options","allSegments","isEmpty","as","handlersFor","hasRoute","output","generateQueryString","pairs","keys","key","value","pair","encodeURIComponent","arrayPair","parseQueryString","queryString","keyLength","isArray","recognize","pathLen","queryStart","isSlashDropped","decodeURI","solutions","map","VERSION","$$route$recognizer$$default","define",4,"Module","Modules","Injectables","registerBuiltIns","Mimeo","instantiateInjectables","injectables","hasAllDependencies","getMissingDependencies","instantiate","bootstrap","injectableName","modules","entryInjectable","Boolean","apply","arguments","dependencies","./Module.js","./builtins/Register.js","./dependencies/Injectables.js","./dependencies/Modules.js",5,"addInjectable","parameters","has","injectable","Function","$inject","$name","factory","component",6,"Deferred","resolvedValue","resolved","resolveCallbacks","rejectCallbacks","notifyCallbacks","promise","then","onResolve","onReject","onNotify","resolve","resolution","forEach","reject","rejectionReason","notify","notification","$q","defer","all","promises","checkComplete","counter","hasRejections","deferred","resolutions","index",7,"Window","window","noOp","onpopstate","onclick","onload","history","pushState","replaceState","Promise","Routing","Context","./Promise.js","./Routing.js",8,"context","$window","preventDefault","event","returnValue","getAttribute","element","attribute","attributes","nodeName","nodeValue","doDefaultRoute","doRouting","queryToDict","query","dict","url","doDefault","urlParts","parseUri","routing","defaultRoute","gotoRoute","replaceRoute","RouteRecognizer","location","href","srcElement","nodeType","parentNode","default","newDefaultRoute","set","html","render","document","getElementById","innerHTML","goto","parseuri","route-recognizer",9,"DependencyManager","register","entity","_providers","_getMissingDependenciesCache","undefined","_graph","hasNodeValue","dependency","addEdge","providersInjects","providerName","filter","getNodesTopological","provider","_instances","dependencyName","getProvider","getInstance","Graph","./Graph.js",10,"Node","String","_id","Math","random","Edge","nodeFrom","nodeTo","_from","_to","makeNodeIdentifier","node1","node2","getNodeIdentifier","_nodes","_nodesById","_nodesByValue","_zeroIngreeNodes","_edges","_edgesByNodes","_edgesByTo","_edgesByFrom","reset","addNode","node","edge","existingNode","removeEdge","edgeToRemove","getNodeByValue","fromValue","toValue","fromNode","toNode","sortedNodes","currentNode","pop","remainingEdges",11,"./DependencyManager.js",12,"instantiateModules"],"mappings":"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","file":"mimeo.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","mimeo = require('./src/Mimeo.js');",null,"/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nmodule.exports = function parseuri(str) {\n    var src = str,\n        b = str.indexOf('['),\n        e = str.indexOf(']');\n\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n\n    var m = re.exec(str || ''),\n        uri = {},\n        i = 14;\n\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n\n    return uri;\n};\n","(function() {\n    \"use strict\";\n    function $$route$recognizer$dsl$$Target(path, matcher, delegate) {\n      this.path = path;\n      this.matcher = matcher;\n      this.delegate = delegate;\n    }\n\n    $$route$recognizer$dsl$$Target.prototype = {\n      to: function(target, callback) {\n        var delegate = this.delegate;\n\n        if (delegate && delegate.willAddRoute) {\n          target = delegate.willAddRoute(this.matcher.target, target);\n        }\n\n        this.matcher.add(this.path, target);\n\n        if (callback) {\n          if (callback.length === 0) { throw new Error(\"You must have an argument in the function passed to `to`\"); }\n          this.matcher.addChild(this.path, target, callback, this.delegate);\n        }\n        return this;\n      }\n    };\n\n    function $$route$recognizer$dsl$$Matcher(target) {\n      this.routes = {};\n      this.children = {};\n      this.target = target;\n    }\n\n    $$route$recognizer$dsl$$Matcher.prototype = {\n      add: function(path, handler) {\n        this.routes[path] = handler;\n      },\n\n      addChild: function(path, target, callback, delegate) {\n        var matcher = new $$route$recognizer$dsl$$Matcher(target);\n        this.children[path] = matcher;\n\n        var match = $$route$recognizer$dsl$$generateMatch(path, matcher, delegate);\n\n        if (delegate && delegate.contextEntered) {\n          delegate.contextEntered(target, match);\n        }\n\n        callback(match);\n      }\n    };\n\n    function $$route$recognizer$dsl$$generateMatch(startingPath, matcher, delegate) {\n      return function(path, nestedCallback) {\n        var fullPath = startingPath + path;\n\n        if (nestedCallback) {\n          nestedCallback($$route$recognizer$dsl$$generateMatch(fullPath, matcher, delegate));\n        } else {\n          return new $$route$recognizer$dsl$$Target(startingPath + path, matcher, delegate);\n        }\n      };\n    }\n\n    function $$route$recognizer$dsl$$addRoute(routeArray, path, handler) {\n      var len = 0;\n      for (var i=0, l=routeArray.length; i<l; i++) {\n        len += routeArray[i].path.length;\n      }\n\n      path = path.substr(len);\n      var route = { path: path, handler: handler };\n      routeArray.push(route);\n    }\n\n    function $$route$recognizer$dsl$$eachRoute(baseRoute, matcher, callback, binding) {\n      var routes = matcher.routes;\n\n      for (var path in routes) {\n        if (routes.hasOwnProperty(path)) {\n          var routeArray = baseRoute.slice();\n          $$route$recognizer$dsl$$addRoute(routeArray, path, routes[path]);\n\n          if (matcher.children[path]) {\n            $$route$recognizer$dsl$$eachRoute(routeArray, matcher.children[path], callback, binding);\n          } else {\n            callback.call(binding, routeArray);\n          }\n        }\n      }\n    }\n\n    var $$route$recognizer$dsl$$default = function(callback, addRouteCallback) {\n      var matcher = new $$route$recognizer$dsl$$Matcher();\n\n      callback($$route$recognizer$dsl$$generateMatch(\"\", matcher, this.delegate));\n\n      $$route$recognizer$dsl$$eachRoute([], matcher, function(route) {\n        if (addRouteCallback) { addRouteCallback(this, route); }\n        else { this.add(route); }\n      }, this);\n    };\n\n    var $$route$recognizer$$specials = [\n      '/', '.', '*', '+', '?', '|',\n      '(', ')', '[', ']', '{', '}', '\\\\'\n    ];\n\n    var $$route$recognizer$$escapeRegex = new RegExp('(\\\\' + $$route$recognizer$$specials.join('|\\\\') + ')', 'g');\n\n    function $$route$recognizer$$isArray(test) {\n      return Object.prototype.toString.call(test) === \"[object Array]\";\n    }\n\n    // A Segment represents a segment in the original route description.\n    // Each Segment type provides an `eachChar` and `regex` method.\n    //\n    // The `eachChar` method invokes the callback with one or more character\n    // specifications. A character specification consumes one or more input\n    // characters.\n    //\n    // The `regex` method returns a regex fragment for the segment. If the\n    // segment is a dynamic of star segment, the regex fragment also includes\n    // a capture.\n    //\n    // A character specification contains:\n    //\n    // * `validChars`: a String with a list of all valid characters, or\n    // * `invalidChars`: a String with a list of all invalid characters\n    // * `repeat`: true if the character specification can repeat\n\n    function $$route$recognizer$$StaticSegment(string) { this.string = string; }\n    $$route$recognizer$$StaticSegment.prototype = {\n      eachChar: function(callback) {\n        var string = this.string, ch;\n\n        for (var i=0, l=string.length; i<l; i++) {\n          ch = string.charAt(i);\n          callback({ validChars: ch });\n        }\n      },\n\n      regex: function() {\n        return this.string.replace($$route$recognizer$$escapeRegex, '\\\\$1');\n      },\n\n      generate: function() {\n        return this.string;\n      }\n    };\n\n    function $$route$recognizer$$DynamicSegment(name) { this.name = name; }\n    $$route$recognizer$$DynamicSegment.prototype = {\n      eachChar: function(callback) {\n        callback({ invalidChars: \"/\", repeat: true });\n      },\n\n      regex: function() {\n        return \"([^/]+)\";\n      },\n\n      generate: function(params) {\n        return params[this.name];\n      }\n    };\n\n    function $$route$recognizer$$StarSegment(name) { this.name = name; }\n    $$route$recognizer$$StarSegment.prototype = {\n      eachChar: function(callback) {\n        callback({ invalidChars: \"\", repeat: true });\n      },\n\n      regex: function() {\n        return \"(.+)\";\n      },\n\n      generate: function(params) {\n        return params[this.name];\n      }\n    };\n\n    function $$route$recognizer$$EpsilonSegment() {}\n    $$route$recognizer$$EpsilonSegment.prototype = {\n      eachChar: function() {},\n      regex: function() { return \"\"; },\n      generate: function() { return \"\"; }\n    };\n\n    function $$route$recognizer$$parse(route, names, specificity) {\n      // normalize route as not starting with a \"/\". Recognition will\n      // also normalize.\n      if (route.charAt(0) === \"/\") { route = route.substr(1); }\n\n      var segments = route.split(\"/\"), results = [];\n\n      // A routes has specificity determined by the order that its different segments\n      // appear in. This system mirrors how the magnitude of numbers written as strings\n      // works.\n      // Consider a number written as: \"abc\". An example would be \"200\". Any other number written\n      // \"xyz\" will be smaller than \"abc\" so long as `a > z`. For instance, \"199\" is smaller\n      // then \"200\", even though \"y\" and \"z\" (which are both 9) are larger than \"0\" (the value\n      // of (`b` and `c`). This is because the leading symbol, \"2\", is larger than the other\n      // leading symbol, \"1\".\n      // The rule is that symbols to the left carry more weight than symbols to the right\n      // when a number is written out as a string. In the above strings, the leading digit\n      // represents how many 100's are in the number, and it carries more weight than the middle\n      // number which represents how many 10's are in the number.\n      // This system of number magnitude works well for route specificity, too. A route written as\n      // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than\n      // `x`, irrespective of the other parts.\n      // Because of this similarity, we assign each type of segment a number value written as a\n      // string. We can find the specificity of compound routes by concatenating these strings\n      // together, from left to right. After we have looped through all of the segments,\n      // we convert the string to a number.\n      specificity.val = '';\n\n      for (var i=0, l=segments.length; i<l; i++) {\n        var segment = segments[i], match;\n\n        if (match = segment.match(/^:([^\\/]+)$/)) {\n          results.push(new $$route$recognizer$$DynamicSegment(match[1]));\n          names.push(match[1]);\n          specificity.val += '3';\n        } else if (match = segment.match(/^\\*([^\\/]+)$/)) {\n          results.push(new $$route$recognizer$$StarSegment(match[1]));\n          specificity.val += '2';\n          names.push(match[1]);\n        } else if(segment === \"\") {\n          results.push(new $$route$recognizer$$EpsilonSegment());\n          specificity.val += '1';\n        } else {\n          results.push(new $$route$recognizer$$StaticSegment(segment));\n          specificity.val += '4';\n        }\n      }\n\n      specificity.val = +specificity.val;\n\n      return results;\n    }\n\n    // A State has a character specification and (`charSpec`) and a list of possible\n    // subsequent states (`nextStates`).\n    //\n    // If a State is an accepting state, it will also have several additional\n    // properties:\n    //\n    // * `regex`: A regular expression that is used to extract parameters from paths\n    //   that reached this accepting state.\n    // * `handlers`: Information on how to convert the list of captures into calls\n    //   to registered handlers with the specified parameters\n    // * `types`: How many static, dynamic or star segments in this route. Used to\n    //   decide which route to use if multiple registered routes match a path.\n    //\n    // Currently, State is implemented naively by looping over `nextStates` and\n    // comparing a character specification against a character. A more efficient\n    // implementation would use a hash of keys pointing at one or more next states.\n\n    function $$route$recognizer$$State(charSpec) {\n      this.charSpec = charSpec;\n      this.nextStates = [];\n    }\n\n    $$route$recognizer$$State.prototype = {\n      get: function(charSpec) {\n        var nextStates = this.nextStates;\n\n        for (var i=0, l=nextStates.length; i<l; i++) {\n          var child = nextStates[i];\n\n          var isEqual = child.charSpec.validChars === charSpec.validChars;\n          isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;\n\n          if (isEqual) { return child; }\n        }\n      },\n\n      put: function(charSpec) {\n        var state;\n\n        // If the character specification already exists in a child of the current\n        // state, just return that state.\n        if (state = this.get(charSpec)) { return state; }\n\n        // Make a new state for the character spec\n        state = new $$route$recognizer$$State(charSpec);\n\n        // Insert the new state as a child of the current state\n        this.nextStates.push(state);\n\n        // If this character specification repeats, insert the new state as a child\n        // of itself. Note that this will not trigger an infinite loop because each\n        // transition during recognition consumes a character.\n        if (charSpec.repeat) {\n          state.nextStates.push(state);\n        }\n\n        // Return the new state\n        return state;\n      },\n\n      // Find a list of child states matching the next character\n      match: function(ch) {\n        // DEBUG \"Processing `\" + ch + \"`:\"\n        var nextStates = this.nextStates,\n            child, charSpec, chars;\n\n        // DEBUG \"  \" + debugState(this)\n        var returned = [];\n\n        for (var i=0, l=nextStates.length; i<l; i++) {\n          child = nextStates[i];\n\n          charSpec = child.charSpec;\n\n          if (typeof (chars = charSpec.validChars) !== 'undefined') {\n            if (chars.indexOf(ch) !== -1) { returned.push(child); }\n          } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {\n            if (chars.indexOf(ch) === -1) { returned.push(child); }\n          }\n        }\n\n        return returned;\n      }\n\n      /** IF DEBUG\n      , debug: function() {\n        var charSpec = this.charSpec,\n            debug = \"[\",\n            chars = charSpec.validChars || charSpec.invalidChars;\n\n        if (charSpec.invalidChars) { debug += \"^\"; }\n        debug += chars;\n        debug += \"]\";\n\n        if (charSpec.repeat) { debug += \"+\"; }\n\n        return debug;\n      }\n      END IF **/\n    };\n\n    /** IF DEBUG\n    function debug(log) {\n      console.log(log);\n    }\n\n    function debugState(state) {\n      return state.nextStates.map(function(n) {\n        if (n.nextStates.length === 0) { return \"( \" + n.debug() + \" [accepting] )\"; }\n        return \"( \" + n.debug() + \" <then> \" + n.nextStates.map(function(s) { return s.debug() }).join(\" or \") + \" )\";\n      }).join(\", \")\n    }\n    END IF **/\n\n    // Sort the routes by specificity\n    function $$route$recognizer$$sortSolutions(states) {\n      return states.sort(function(a, b) {\n        return b.specificity.val - a.specificity.val;\n      });\n    }\n\n    function $$route$recognizer$$recognizeChar(states, ch) {\n      var nextStates = [];\n\n      for (var i=0, l=states.length; i<l; i++) {\n        var state = states[i];\n\n        nextStates = nextStates.concat(state.match(ch));\n      }\n\n      return nextStates;\n    }\n\n    var $$route$recognizer$$oCreate = Object.create || function(proto) {\n      function F() {}\n      F.prototype = proto;\n      return new F();\n    };\n\n    function $$route$recognizer$$RecognizeResults(queryParams) {\n      this.queryParams = queryParams || {};\n    }\n    $$route$recognizer$$RecognizeResults.prototype = $$route$recognizer$$oCreate({\n      splice: Array.prototype.splice,\n      slice:  Array.prototype.slice,\n      push:   Array.prototype.push,\n      length: 0,\n      queryParams: null\n    });\n\n    function $$route$recognizer$$findHandler(state, path, queryParams) {\n      var handlers = state.handlers, regex = state.regex;\n      var captures = path.match(regex), currentCapture = 1;\n      var result = new $$route$recognizer$$RecognizeResults(queryParams);\n\n      for (var i=0, l=handlers.length; i<l; i++) {\n        var handler = handlers[i], names = handler.names, params = {};\n\n        for (var j=0, m=names.length; j<m; j++) {\n          params[names[j]] = captures[currentCapture++];\n        }\n\n        result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });\n      }\n\n      return result;\n    }\n\n    function $$route$recognizer$$addSegment(currentState, segment) {\n      segment.eachChar(function(ch) {\n        var state;\n\n        currentState = currentState.put(ch);\n      });\n\n      return currentState;\n    }\n\n    function $$route$recognizer$$decodeQueryParamPart(part) {\n      // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n      part = part.replace(/\\+/gm, '%20');\n      return decodeURIComponent(part);\n    }\n\n    // The main interface\n\n    var $$route$recognizer$$RouteRecognizer = function() {\n      this.rootState = new $$route$recognizer$$State();\n      this.names = {};\n    };\n\n\n    $$route$recognizer$$RouteRecognizer.prototype = {\n      add: function(routes, options) {\n        var currentState = this.rootState, regex = \"^\",\n            specificity = {},\n            handlers = [], allSegments = [], name;\n\n        var isEmpty = true;\n\n        for (var i=0, l=routes.length; i<l; i++) {\n          var route = routes[i], names = [];\n\n          var segments = $$route$recognizer$$parse(route.path, names, specificity);\n\n          allSegments = allSegments.concat(segments);\n\n          for (var j=0, m=segments.length; j<m; j++) {\n            var segment = segments[j];\n\n            if (segment instanceof $$route$recognizer$$EpsilonSegment) { continue; }\n\n            isEmpty = false;\n\n            // Add a \"/\" for the new segment\n            currentState = currentState.put({ validChars: \"/\" });\n            regex += \"/\";\n\n            // Add a representation of the segment to the NFA and regex\n            currentState = $$route$recognizer$$addSegment(currentState, segment);\n            regex += segment.regex();\n          }\n\n          var handler = { handler: route.handler, names: names };\n          handlers.push(handler);\n        }\n\n        if (isEmpty) {\n          currentState = currentState.put({ validChars: \"/\" });\n          regex += \"/\";\n        }\n\n        currentState.handlers = handlers;\n        currentState.regex = new RegExp(regex + \"$\");\n        currentState.specificity = specificity;\n\n        if (name = options && options.as) {\n          this.names[name] = {\n            segments: allSegments,\n            handlers: handlers\n          };\n        }\n      },\n\n      handlersFor: function(name) {\n        var route = this.names[name], result = [];\n        if (!route) { throw new Error(\"There is no route named \" + name); }\n\n        for (var i=0, l=route.handlers.length; i<l; i++) {\n          result.push(route.handlers[i]);\n        }\n\n        return result;\n      },\n\n      hasRoute: function(name) {\n        return !!this.names[name];\n      },\n\n      generate: function(name, params) {\n        var route = this.names[name], output = \"\";\n        if (!route) { throw new Error(\"There is no route named \" + name); }\n\n        var segments = route.segments;\n\n        for (var i=0, l=segments.length; i<l; i++) {\n          var segment = segments[i];\n\n          if (segment instanceof $$route$recognizer$$EpsilonSegment) { continue; }\n\n          output += \"/\";\n          output += segment.generate(params);\n        }\n\n        if (output.charAt(0) !== '/') { output = '/' + output; }\n\n        if (params && params.queryParams) {\n          output += this.generateQueryString(params.queryParams, route.handlers);\n        }\n\n        return output;\n      },\n\n      generateQueryString: function(params, handlers) {\n        var pairs = [];\n        var keys = [];\n        for(var key in params) {\n          if (params.hasOwnProperty(key)) {\n            keys.push(key);\n          }\n        }\n        keys.sort();\n        for (var i = 0, len = keys.length; i < len; i++) {\n          key = keys[i];\n          var value = params[key];\n          if (value == null) {\n            continue;\n          }\n          var pair = encodeURIComponent(key);\n          if ($$route$recognizer$$isArray(value)) {\n            for (var j = 0, l = value.length; j < l; j++) {\n              var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);\n              pairs.push(arrayPair);\n            }\n          } else {\n            pair += \"=\" + encodeURIComponent(value);\n            pairs.push(pair);\n          }\n        }\n\n        if (pairs.length === 0) { return ''; }\n\n        return \"?\" + pairs.join(\"&\");\n      },\n\n      parseQueryString: function(queryString) {\n        var pairs = queryString.split(\"&\"), queryParams = {};\n        for(var i=0; i < pairs.length; i++) {\n          var pair      = pairs[i].split('='),\n              key       = $$route$recognizer$$decodeQueryParamPart(pair[0]),\n              keyLength = key.length,\n              isArray = false,\n              value;\n          if (pair.length === 1) {\n            value = 'true';\n          } else {\n            //Handle arrays\n            if (keyLength > 2 && key.slice(keyLength -2) === '[]') {\n              isArray = true;\n              key = key.slice(0, keyLength - 2);\n              if(!queryParams[key]) {\n                queryParams[key] = [];\n              }\n            }\n            value = pair[1] ? $$route$recognizer$$decodeQueryParamPart(pair[1]) : '';\n          }\n          if (isArray) {\n            queryParams[key].push(value);\n          } else {\n            queryParams[key] = value;\n          }\n        }\n        return queryParams;\n      },\n\n      recognize: function(path) {\n        var states = [ this.rootState ],\n            pathLen, i, l, queryStart, queryParams = {},\n            isSlashDropped = false;\n\n        queryStart = path.indexOf('?');\n        if (queryStart !== -1) {\n          var queryString = path.substr(queryStart + 1, path.length);\n          path = path.substr(0, queryStart);\n          queryParams = this.parseQueryString(queryString);\n        }\n\n        path = decodeURI(path);\n\n        // DEBUG GROUP path\n\n        if (path.charAt(0) !== \"/\") { path = \"/\" + path; }\n\n        pathLen = path.length;\n        if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n          path = path.substr(0, pathLen - 1);\n          isSlashDropped = true;\n        }\n\n        for (i=0, l=path.length; i<l; i++) {\n          states = $$route$recognizer$$recognizeChar(states, path.charAt(i));\n          if (!states.length) { break; }\n        }\n\n        // END DEBUG GROUP\n\n        var solutions = [];\n        for (i=0, l=states.length; i<l; i++) {\n          if (states[i].handlers) { solutions.push(states[i]); }\n        }\n\n        states = $$route$recognizer$$sortSolutions(solutions);\n\n        var state = solutions[0];\n\n        if (state && state.handlers) {\n          // if a trailing slash was dropped and a star segment is the last segment\n          // specified, put the trailing slash back\n          if (isSlashDropped && state.regex.source.slice(-5) === \"(.+)$\") {\n            path = path + \"/\";\n          }\n          return $$route$recognizer$$findHandler(state, path, queryParams);\n        }\n      }\n    };\n\n    $$route$recognizer$$RouteRecognizer.prototype.map = $$route$recognizer$dsl$$default;\n\n    $$route$recognizer$$RouteRecognizer.VERSION = '0.1.9';\n\n    var $$route$recognizer$$default = $$route$recognizer$$RouteRecognizer;\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define('route-recognizer', function() { return $$route$recognizer$$default; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = $$route$recognizer$$default;\n    } else if (typeof this !== 'undefined') {\n      this['RouteRecognizer'] = $$route$recognizer$$default;\n    }\n}).call(this);\n\n//# sourceMappingURL=route-recognizer.js.map","var Module = require('./Module.js');\n\nvar Modules = require('./dependencies/Modules.js');\nvar Injectables = require('./dependencies/Injectables.js');\n\nvar registerBuiltIns = require('./builtins/Register.js');\n\nvar Mimeo = function() {\n    var modules = Modules();\n    var injectables = Injectables();\n\n    registerBuiltIns(injectables);\n\n    function instantiateInjectables() {\n        if (!injectables.hasAllDependencies()) {\n            throw new Error('Injectables don\\'t exist: ' + injectables.getMissingDependencies());\n        }\n\n        injectables.instantiate();\n    }\n\n    function bootstrap(injectableName) {\n        if (!injectableName) {\n            throw new Error('Define an injectable to bootstrap!');\n        }\n\n        modules.instantiate();\n\n        instantiateInjectables();\n\n        var entryInjectable = injectables.get(injectableName);\n\n        if (!Boolean(entryInjectable)) {\n            throw new Error('Injectable \"' + injectableName + '\" to bootstrap not found');\n        }\n\n        return entryInjectable.apply(entryInjectable, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return {\n        module: function(name, dependencies) {\n            if (dependencies) {\n                return modules.add(new Module(injectables, name, dependencies));\n            }\n\n            return modules.get(name);\n        },\n        bootstrap: bootstrap\n    }\n};\n\nmodule.exports = Mimeo();\n","function Module(injectables, name, dependencies) {\n    var module = this;\n\n    this.$name = name;\n    this.$inject = dependencies;\n\n    function addInjectable(name, parameters) {\n        if (injectables.has(name)) {\n            throw new Error('Injectable \"' + name + '\" already exists');\n        }\n\n        var injectable;\n\n        if (parameters instanceof Function) {\n            injectable = parameters;\n            if (!injectable.$inject) {\n                injectable.$inject = [];\n            }\n        } else {\n            var dependencies = parameters.slice(0, -1);\n            injectable = parameters.slice(-1)[0];\n            injectable.$inject = dependencies;\n        }\n\n        injectable.$name = name;\n\n        injectables.add(injectable);\n\n        return module;\n    }\n\n    this.factory = addInjectable;\n    this.component = addInjectable;\n    this.value = function(name, value) {\n        return addInjectable(name, function() {\n            return value;\n        });\n    }\n}\n\nmodule.exports = Module;","function Deferred(callback) {\n    var resolved = false;\n    var resolvedValue;\n\n    var resolveCallbacks = [];\n    var rejectCallbacks = [];\n    var notifyCallbacks = [];\n\n    var promise = {\n        then: function(onResolve, onReject, onNotify) {\n            if (resolved && onResolve) {\n                onResolve(resolvedValue);\n            } else {\n                resolveCallbacks.push(onResolve);\n            }\n\n            if (onReject) {\n                rejectCallbacks.push(onReject);\n            }\n\n            if (onNotify) {\n                notifyCallbacks.push(onNotify);\n            }\n        }\n    };\n\n    var resolve = function(resolution) {\n        resolveCallbacks.forEach(function(callback) {\n            callback(resolution);\n        });\n    };\n    var reject = function(rejectionReason) {\n        rejectCallbacks.forEach(function(callback) {\n            callback(rejectionReason);\n        });\n    };\n    var notify = function(notification) {\n        notifyCallbacks.forEach(function(callback) {\n            callback(notification);\n        });\n    };\n\n    if (callback) {\n        callback(resolve, reject, notify);\n    }\n\n    return {\n        resolve: resolve,\n        reject: reject,\n        notify: notify,\n        promise: promise\n    };\n}\n\nfunction $q(callback) {\n    return (new Deferred(callback)).promise;\n}\n\n$q.defer = function() {\n    return new Deferred();\n};\n\n$q.all = function(promises) {\n    if (!promises instanceof Array) {\n        throw new Error('Promises need to be passed to $q.all in an array');\n    }\n\n    var counter = 0;\n    var resolutions = [];\n    var hasRejections = false;\n\n    var deferred = new Deferred();\n\n    function checkComplete() {\n        if (counter === promises.length) {\n            if (hasRejections) {\n                deferred.reject();\n            } else {\n                deferred.resolve(resolutions);\n            }\n        }\n    }\n\n    promises.forEach(function(promise, index) {\n        promise.then(function(resolution) {\n            resolutions[index] = resolution;\n            ++counter;\n            checkComplete();\n        }, function() {\n            hasRejections = true;\n            ++counter;\n            checkComplete();\n        });\n    });\n\n    return deferred.promise;\n};\n\nmodule.exports = function() {\n    return $q;\n};","var Promise = require('./Promise.js');\nvar Routing = require('./Routing.js');\n\nfunction Window() {\n    if (typeof window === 'undefined') {\n        var noOp = function() {\n        };\n        return {\n            onpopstate: noOp,\n            onclick: noOp,\n            onload: noOp,\n            history: {\n                pushState: noOp,\n                replaceState: noOp\n            }\n        };\n    }\n\n    return window;\n}\n\nmodule.exports = function(injectables) {\n    Window.$name = '$window';\n    Window.$inject = [];\n\n    injectables.add(Window);\n\n    Routing.Context.$name = '$context';\n    Routing.Context.$inject = [];\n\n    Routing.Routing.$name = '$routing';\n    Routing.Routing.$inject = ['$window'];\n\n    injectables.add(Routing.Context);\n    injectables.add(Routing.Routing);\n\n    Promise.$name = '$q';\n    Promise.$inject = [];\n\n    injectables.add(Promise);\n};\n","var RouteRecognizer = require('route-recognizer');\nvar parseUri = require('parseuri');\n\nvar context = {};\nfunction Context() {\n    return function() {\n        return context;\n    }\n}\n\nfunction Routing($window) {\n    var routing = new RouteRecognizer();\n    var defaultRoute;\n\n    function preventDefault(event) {\n        if (event.preventDefault) {\n            event.preventDefault();\n        } else {\n            /*\n             * Internet explorer support\n             */\n            event.returnValue = false;\n        }\n    }\n\n    function getAttribute(element, attribute) {\n        if (element[attribute]) {\n            return element[attribute];\n        }\n\n        if (element.getAttribute) {\n            return element.getAttribute(attribute);\n        }\n\n        var value = null;\n        for (var i = 0; i < element.attributes.length; ++i) {\n            if (element.attributes[i].nodeName === attribute) {\n                value = element.attributes[i].nodeValue;\n            }\n        }\n\n        return value;\n    }\n\n    function doDefaultRoute(route) {\n        if (route) {\n            $window.history.pushState(null, '', route);\n            doRouting(route, false);\n        }\n    }\n\n    function queryToDict(query) {\n        var dict = {};\n        query.split('&').map(function(part) {\n            return part.split('=').map(decodeURIComponent);\n        }).forEach(function(part) {\n            dict[part[0]] = part[1];\n        });\n\n        return dict;\n    }\n\n    function doRouting(url, doDefault) {\n        var urlParts = parseUri(url);\n        var handlers = routing.recognize(urlParts.path);\n        if (handlers) {\n            for (var i=0; i<handlers.length; ++i) {\n                context = {\n                    url: urlParts,\n                    params: handlers.params,\n                    query: queryToDict(urlParts.query)\n                };\n\n                handlers[i].handler();\n            }\n        } else if (doDefault !== false) {\n            doDefaultRoute(defaultRoute);\n        }\n    }\n\n    function gotoRoute(route) {\n        $window.history.pushState(null,\n            '',\n            route);\n        doRouting(route);\n    }\n\n    function replaceRoute(route) {\n        $window.history.replaceState(null,\n            '',\n            route);\n\n        doRouting(route);\n    }\n\n    $window.onpopstate = function() {\n        doRouting($window.location.href);\n    };\n\n    $window.onclick = function(event) {\n        var target = event.target || event.srcElement;\n\n        /*\n         * Related to Safari firing events on text nodes\n         */\n        if (target.nodeType === 3) {\n            target = target.parentNode;\n        }\n\n        if (getAttribute(target, 'data-internal') !== null) {\n            preventDefault(event);\n\n            if (getAttribute(target, 'data-no-history') !== null) {\n                replaceRoute(getAttribute(target, 'href'));\n            } else {\n                gotoRoute(getAttribute(target, 'href'));\n            }\n        }\n    };\n\n    $window.onload = function() {\n        doRouting($window.location.href);\n    };\n\n    return {\n        'default': function(newDefaultRoute) {\n            defaultRoute = newDefaultRoute;\n        },\n        'set': function(route, target, injectable, name) {\n            routing.add([\n                {\n                    path: route,\n                    handler: function() {\n                        var html;\n\n                        if (injectable.render) {\n                            html = injectable.render();\n                        } else {\n                            html = injectable();\n                        }\n\n                        $window.document.getElementById(target).innerHTML = html;\n                    }\n                }\n            ], {'as': name});\n        },\n        'goto': function(route) {\n            gotoRoute(route);\n        }\n    }\n}\n\nmodule.exports = {\n    'Context': Context,\n    'Routing': Routing\n};","//var DependencyResolver = require('./DependencyResolver.js');\nvar Graph = require('./Graph.js');\n\n/**\n *\n * @param name\n * @returns {{$name: string, register: register, hasAllDependencies:\n *     hasAllDependencies, instantiate: instantiate, getInstance: getInstance}}\n * @constructor\n */\nfunction DependencyManager(name) {\n    var _providers = {};\n    var _instances = {};\n    var _graph = new Graph();\n\n    var _getMissingDependenciesCache = undefined;\n\n    function register(entity) {\n        if (!entity) {\n            throw new Error('No entity to register was given');\n        }\n\n        if (!entity.$name) {\n            throw new Error('Entity \"' + entity.$name + '\" is missing property $name');\n        }\n\n        if (!entity.$inject) {\n            throw new Error('Entity \"' + entity.$name + '\" is missing property $inject');\n        }\n\n        if (_providers[entity.$name]) {\n            throw new Error('Entity \"' + entity.$name + '\" already exists');\n        }\n\n        _getMissingDependenciesCache = undefined;\n\n        _providers[entity.$name] = entity;\n\n        /*\n         * Name might've been registered as a dependency of another entity\n         */\n        if (!_graph.hasNodeValue(entity.$name)) {\n            _graph.add(entity.$name);\n        }\n\n        entity.$inject.forEach(function(dependency) {\n            if (!_graph.hasNodeValue(dependency)) {\n                _graph.add(dependency);\n            }\n\n            _graph.addEdge(dependency, entity.$name);\n        });\n    }\n\n    function getMissingDependencies() {\n        if (_getMissingDependenciesCache) {\n            return _getMissingDependenciesCache;\n        }\n\n        var providersInjects = Object.keys(_providers).map(function(providerName) {\n            return _providers[providerName].$inject;\n        });\n\n        _getMissingDependenciesCache = [].concat.apply([], providersInjects).filter(function(providerName) {\n            return !Boolean(_providers[providerName]);\n        });\n\n        return _getMissingDependenciesCache;\n    }\n\n    function hasAllDependencies() {\n        return getMissingDependencies().length == 0;\n    }\n\n    function instantiate() {\n        _graph.getNodesTopological().forEach(function(providerName) {\n            var provider = _providers[providerName];\n\n            _instances[providerName] = provider.apply(provider, provider.$inject.map(function(dependencyName) {\n                return _instances[dependencyName];\n            }));\n        });\n    }\n\n    function getProvider(providerName) {\n        return _providers[providerName];\n    }\n\n    function getInstance(providerName) {\n        return _instances[providerName];\n    }\n\n    return {\n        $name: name,\n        register: register,\n        hasAllDependencies: hasAllDependencies,\n        getMissingDependencies: getMissingDependencies,\n        instantiate: instantiate,\n        getProvider: getProvider,\n        getInstance: getInstance\n    }\n}\n\n/**\n *\n * @param name\n * @returns {DependencyManager}\n */\nmodule.exports = function(name) {\n    return new DependencyManager(name);\n};","var Node = function(value) {\n    if (!(value instanceof String || typeof value === 'string')) {\n        throw new Error('Only strings are accepted as node values');\n    }\n\n    this._id = Math.random().toString(36);\n    this.value = value;\n};\n\n\nvar Edge = function(nodeFrom, nodeTo) {\n    this._id = Math.random().toString(36);\n    this._from = nodeFrom;\n    this._to = nodeTo;\n};\n\nvar makeNodeIdentifier = function(node1, node2) {\n    return node1._id + ':' + node2._id;\n};\n\nEdge.prototype.getNodeIdentifier = function() {\n    return makeNodeIdentifier(this._from, this._to);\n};\n\n/**\n * Directed graph to order nodes by dependencies. Only handles values whose\n * .toString() function returns unique values. Favors pre-computed lookup\n * tables over lookups at sort time. Most machines have lots of ram and\n * especially on mobile the CPU is more restricted. Using more ram and less\n * CPU cycles is preferable in those conditions, although it should hardly\n * matter since most dependency graphs (which this implementation is focused\n * on) shouldn't exceed a few hundred nodes.\n *\n * @returns {{add: Function, addEdge: Function, hasNodeValue: Function,\n *     getNodesTopological: Function}}\n * @constructor\n */\nvar Graph = function() {\n    var _nodes = [];\n    var _nodesById = {};\n    var _nodesByValue = {};\n    var _zeroIngreeNodes = [];\n    var _edges = [];\n    var _edgesByNodes = {};\n    var _edgesByTo = {};\n    var _edgesByFrom = {};\n\n    /*\n     * The current topological sort implementation mutates the graph, after\n     * which it's unusable. This function allows to clean the entire graph\n     * up, removing any dangling data that might be left after the sort.\n     */\n    var reset = function() {\n        _nodes = [];\n        _nodesById = {};\n        _nodesByValue = {};\n        _zeroIngreeNodes = [];\n        _edges = [];\n        _edgesByNodes = {};\n        _edgesByTo = {};\n        _edgesByFrom = {};\n    };\n\n    var addNode = function(node) {\n        if (_nodesByValue[node.value]) {\n            throw new Error('Duplicate values not allowed. Node with value \"' + node.value + '\" already exists');\n        }\n\n        _nodes.push(node);\n        _nodesById[node._id] = node;\n        _nodesByValue[node.value] = node;\n\n        _zeroIngreeNodes.push(node);\n    };\n\n    var addEdge = function(edge) {\n        if (_edgesByNodes[edge.getNodeIdentifier()]) {\n            return;\n        }\n\n        _edges.push(edge);\n        _edgesByNodes[edge.getNodeIdentifier()] = edge;\n\n        if (!_edgesByFrom[edge._from._id]) {\n            _edgesByFrom[edge._from._id] = [];\n        }\n        _edgesByFrom[edge._from._id].push(edge);\n\n        if (!_edgesByTo[edge._to._id]) {\n            _edgesByTo[edge._to._id] = [];\n        }\n        _edgesByTo[edge._to._id].push(edge);\n\n        _zeroIngreeNodes = _zeroIngreeNodes.filter(function(existingNode) {\n            return existingNode._id != edge._to._id;\n        });\n    };\n    var removeEdge = function(edgeToRemove) {\n        _edges = _edges.filter(function(edge) {\n            return edge._id != edgeToRemove._id;\n        });\n\n        delete _edgesByNodes[edgeToRemove.getNodeIdentifier()];\n\n        _edgesByFrom[edgeToRemove._from._id] = _edgesByFrom[edgeToRemove._from._id].filter(function(edge) {\n            return edge._id != edgeToRemove._id;\n        });\n\n        _edgesByTo[edgeToRemove._to._id] = _edgesByTo[edgeToRemove._to._id].filter(function(edge) {\n            return edge._id != edgeToRemove._id;\n        });\n    };\n\n    var getNodeByValue = function(value) {\n        return _nodesByValue[value];\n    };\n\n    return {\n        add: function(value) {\n            addNode(new Node(value));\n        },\n        addEdge: function(fromValue, toValue) {\n            var fromNode = getNodeByValue(fromValue);\n            var toNode = getNodeByValue(toValue);\n\n            if (!fromNode && !toNode) {\n                throw 'Neither from- nor to-node exist: ' + fromValue + ', ' + toValue;\n            }\n\n            if (!fromNode) {\n                throw 'From-node doesn\\'t exist: ' + fromValue;\n            }\n\n            if (!toNode) {\n                throw 'To-node doesn\\'t exist: ' + toValue;\n            }\n\n            addEdge(new Edge(fromNode, toNode));\n        },\n        hasNodeValue: function(value) {\n            return Boolean(getNodeByValue(value));\n        },\n        getNodesTopological: function() {\n            var sortedNodes = [];\n\n            while (_zeroIngreeNodes.length > 0) {\n                var currentNode = _zeroIngreeNodes.pop();\n                sortedNodes.push(currentNode);\n                (_edgesByFrom[currentNode._id] || []).slice(0).forEach(function(edge) {\n                    removeEdge(edge);\n                    if (!_edgesByTo[edge._to._id] || _edgesByTo[edge._to._id].length < 1) {\n                        _zeroIngreeNodes.push(edge._to);\n                    }\n                });\n            }\n\n            if (_edges.length > 0) {\n                var remainingEdges = _edges.map(function(edge) {\n                    return '(' + edge._from.value + ',' + edge._to.value + ')';\n                });\n\n                reset();\n\n                throw new Error('Cycle detected, remaining edges: ' + remainingEdges);\n            }\n\n            reset();\n\n            return sortedNodes.map(function(node) {\n                return node.value;\n            });\n        }\n    };\n};\n\nmodule.exports = Graph;","var DependencyManager = require('./DependencyManager.js');\n\nmodule.exports = function() {\n    var injectables = DependencyManager('injectables');\n\n    function add(injectable) {\n        injectables.register(injectable);\n        return injectable;\n    }\n\n    function instantiateInjectables() {\n        if (!injectables.hasAllDependencies()) {\n            throw new Error('Injectables don\\'t exist: ' + injectables.getMissingDependencies());\n        }\n\n        injectables.instantiate();\n    }\n\n    function has(name) {\n        return Boolean(injectables.getProvider(name));\n    }\n\n    function get(name) {\n        return injectables.getInstance(name);\n    }\n\n    function hasAllDependencies() {\n        return injectables.hasAllDependencies();\n    }\n\n    function getMissingDependencies() {\n        return injectables.getMissingDependencies();\n    }\n\n    return {\n        add: add,\n        get: get,\n        has: has,\n        instantiate: instantiateInjectables,\n        hasAllDependencies: hasAllDependencies,\n        getMissingDependencies: getMissingDependencies\n    };\n};","var DependencyManager = require('./DependencyManager.js');\n\nmodule.exports = function() {\n    var modules = DependencyManager('modules');\n\n    function add(module) {\n        modules.register(module);\n        return module;\n    }\n\n    function instantiateModules() {\n        if (!modules.hasAllDependencies()) {\n            throw new Error('Modules don\\'t exist: ' + modules.getMissingDependencies());\n        }\n    }\n\n    function get(name) {\n        return modules.getProvider(name);\n    }\n\n    return {\n        add: add,\n        get: get,\n        instantiate: instantiateModules\n    };\n};"],"sourceRoot":"/source/"}